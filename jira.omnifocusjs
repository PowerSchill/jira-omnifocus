/*{
  "type": "action",
  "targets": ["omnifocus"],
  "author": "Mark E. Schill",
  "identifier": "net.cmschill.omnifocus.sync.jira",
  "version": "1.5.0",
  "description": "Sync elements from Jira with Omnifocus",
  "label": "ðŸ”¹ Jira: Sync",
  "shortLabel": "Jira: sync"
}*/
(() => {
  const maxResultsPerPage = 25;

  const shouldLogToConsole = true;
  const serviceTitle = "JIRA Sync";
  const credentials = new Credentials();
  const preferences = new Preferences();

  const log = (...args) => {
    if (shouldLogToConsole) console.log(...args);
  };

  const isSuccessfulStatus = (statusCode) =>
    typeof statusCode === "number" && statusCode >= 200 && statusCode < 300;

  const getBasicAuthHeader = (userID, apiKey) =>
    "Basic " + Data.fromString(userID + ":" + apiKey).toBase64();

  const parseJsonSafely = (text) => {
    try {
      return JSON.parse(text);
    } catch {
      return null;
    }
  };

  const formatJiraError = (statusCode, bodyString) => {
    const json = parseJsonSafely(bodyString);
    if (json) {
      const messageParts = [];
      if (Array.isArray(json.errorMessages) && json.errorMessages.length) {
        messageParts.push(json.errorMessages.join(", "));
      }
      if (json.errors && typeof json.errors === "object") {
        const kv = Object.entries(json.errors)
          .map(([k, v]) => `${k}: ${v}`)
          .join(", ");
        if (kv) messageParts.push(kv);
      }
      const msg = messageParts.filter(Boolean).join(" | ");
      if (msg) return `Jira request failed (HTTP ${statusCode}): ${msg}`;
    }

    const snippet =
      typeof bodyString === "string" && bodyString.trim().length
        ? bodyString.trim().slice(0, 500)
        : "";
    return snippet
      ? `Jira request failed (HTTP ${statusCode}): ${snippet}`
      : `Jira request failed (HTTP ${statusCode}).`;
  };

  const fetchJiraJson = async ({ url, authHeader }) => {
    const request = URL.FetchRequest.fromString(url);
    request.method = "GET";
    request.headers = {
      Authorization: authHeader,
      Accept: "application/json"
    };

    const response = await request.fetch();
    const statusCode = response.statusCode;
    const bodyString = response.bodyString || "";

    if (!isSuccessfulStatus(statusCode)) {
      throw new Error(formatJiraError(statusCode, bodyString));
    }

    const json = parseJsonSafely(bodyString);
    if (!json) {
      const snippet = bodyString.trim().slice(0, 500);
      throw new Error(
        snippet
          ? `Unexpected non-JSON response from Jira: ${snippet}`
          : "Unexpected empty response from Jira."
      );
    }

    return json;
  };

  const jiraDescriptionToText = (description) => {
    if (!description) return "No description";
    if (typeof description === "string") return description;

    // Jira Cloud often returns "description" as Atlassian Document Format (ADF)
    // https://developer.atlassian.com/cloud/jira/platform/apis/document/structure/
    const isAdfDoc =
      typeof description === "object" &&
      description !== null &&
      description.type === "doc" &&
      Array.isArray(description.content);

    if (!isAdfDoc) return "No description";

    const lines = [];

    const pushLine = (s = "") => {
      const str = String(s);
      // avoid runaway blank lines
      if (str === "" && lines.length && lines[lines.length - 1] === "") return;
      lines.push(str);
    };

    const renderInline = (node) => {
      if (!node || typeof node !== "object") return "";
      if (node.type === "text") return node.text || "";
      if (node.type === "hardBreak") return "\n";
      if (Array.isArray(node.content)) return node.content.map(renderInline).join("");
      return "";
    };

    const renderBlock = (node, listPrefix = "") => {
      if (!node || typeof node !== "object") return;

      switch (node.type) {
        case "paragraph":
        case "heading": {
          const text = Array.isArray(node.content)
            ? node.content.map(renderInline).join("")
            : "";
          const normalized = text.replace(/\n{3,}/g, "\n\n").trimEnd();
          if (normalized.trim().length) {
            const split = normalized.split("\n");
            if (split.length === 1) {
              pushLine(listPrefix + split[0]);
            } else {
              // keep multi-line paragraphs (e.g., hardBreaks)
              pushLine(listPrefix + split[0]);
              for (let i = 1; i < split.length; i++) pushLine(split[i]);
            }
          }
          pushLine("");
          return;
        }
        case "codeBlock": {
          const text = Array.isArray(node.content)
            ? node.content.map(renderInline).join("")
            : "";
          const trimmed = text.trimEnd();
          if (trimmed.length) {
            pushLine(listPrefix + trimmed);
            pushLine("");
          }
          return;
        }
        case "bulletList": {
          if (Array.isArray(node.content)) {
            for (const item of node.content) renderBlock(item, "- ");
          }
          pushLine("");
          return;
        }
        case "orderedList": {
          if (Array.isArray(node.content)) {
            let i = 1;
            for (const item of node.content) {
              renderBlock(item, `${i}. `);
              i++;
            }
          }
          pushLine("");
          return;
        }
        case "listItem": {
          // render list item blocks; prefix first paragraph
          if (Array.isArray(node.content)) {
            let usedPrefix = false;
            for (const child of node.content) {
              const prefix = usedPrefix ? "  " : listPrefix;
              renderBlock(child, prefix);
              usedPrefix = true;
            }
          }
          return;
        }
        default: {
          if (Array.isArray(node.content)) {
            for (const child of node.content) renderBlock(child, listPrefix);
          }
          return;
        }
      }
    };

    for (const node of description.content) renderBlock(node);

    const joined = lines.join("\n").replace(/\n{3,}/g, "\n\n").trim();
    return joined.length ? joined : "No description";
  };

  const getOrCreateTagFromPath = (tagPath) => {
    const parts = String(tagPath)
      .split(" : ")
      .map((p) => p.trim())
      .filter(Boolean);

    if (!parts.length) return null;

    let current =
      tags.byName(parts[0]) || flattenedTags.byName(parts[0]) || new Tag(parts[0]);

    for (let i = 1; i < parts.length; i++) {
      const name = parts[i];
      let child = current.childNamed(name);
      if (!child) child = new Tag(name, current);
      current = child;
    }

    return current;
  };

  const action = new PlugIn.Action(async function (selection, sender) {
    if (shouldLogToConsole) {
      console.log("Starting JIRA Sync...");
    }

    const credentialsObj = credentials.read(serviceTitle);

    if (app.controlKeyDown) {
      // Prompt the user to confirm the removal of stored credentials
      const alertMessage = "Remove the stored credentials?";
      const alert = new Alert("Confirmation Required", alertMessage);
      alert.addOption("Reset");
      alert.addOption("Cancel");

      // Show the alert and get the user's response
      const buttonIndex = await alert.show();

      // If the user chose "Reset", remove the stored credentials
      if (buttonIndex === 0) {
        credentials.remove(serviceTitle);
      }
    } else if (!credentialsObj) {
      const inputForm = new Form();

      const userIDField = new Form.Field.String("userID", "User ID", null);
      if (Device.iPad || Device.iOS) {
        userIDField.autocapitalizationType = TextAutocapitalizationType.None;
      }

      const APIKeyField = new Form.Field.String("apiKey", "API Key", null);
      if (Device.iPad || Device.iOS) {
        APIKeyField.autocapitalizationType = TextAutocapitalizationType.None;
      }

      inputForm.addField(userIDField);
      inputForm.addField(APIKeyField);

      inputForm.validate = (formObject) => {
        const userID = formObject.values["userID"];
        const APIKey = formObject.values["apiKey"];
        return userID && APIKey ? true : false;
      };

      const formPrompt = "Enter your JIRA credentials:";
      const formObject = await inputForm.show(formPrompt, "Continue");

      const userID = formObject.values["userID"];
      const apiKey = formObject.values["apiKey"];

      credentials.write(serviceTitle, userID, apiKey);
    } else {
      try {
        // Start timing the sync
        const syncStartTime = Date.now();

        // Initialize sync statistics
        const syncStats = {
          created: 0,
          reopened: 0,
          completed: 0
        };

        const userID = credentialsObj.user;
        const apiKey = credentialsObj.password;
        const authHeader = getBasicAuthHeader(userID, apiKey);

        log("User ID:", userID);

        const jiraUrlDefault =
          preferences.readString("jiraUrl") || "https://jira.atlassian.com";
        const jiraUrlInputField = new Form.Field.String(
          "jiraUrl",
          "URL",
          jiraUrlDefault
        );

        const omniFocusTagDefault = preferences.readString("omniFocusTag") || "jira";
        const omniFocusTagInputField = new Form.Field.String(
          "omniFocusTag",
          "OmniFocus Tag",
          omniFocusTagDefault
        );

        const jiraQueryDefault =
          preferences.readString("jiraQuery") ||
          "assignee=currentuser() and resolution is empty";
        const jiraQueryInputField = new Form.Field.String(
          "jiraQuery",
          "JIRA Search Query",
          jiraQueryDefault
        );

        const inputForm = new Form();
        inputForm.addField(jiraUrlInputField);
        inputForm.addField(omniFocusTagInputField);
        inputForm.addField(jiraQueryInputField);
        const formPrompt = action.label;
        const formObject = await inputForm.show(formPrompt, "Continue");

        const jiraUrl = String(formObject.values["jiraUrl"] || "").trim();
        if (!jiraUrl) throw new Error("Jira URL is required.");
        preferences.write("jiraUrl", jiraUrl);
        const omniFocusTag = String(formObject.values["omniFocusTag"] || "").trim();
        if (!omniFocusTag) throw new Error("OmniFocus Tag is required.");
        preferences.write("omniFocusTag", omniFocusTag);
        const jiraQuery = String(formObject.values["jiraQuery"] || "").trim();
        if (!jiraQuery) throw new Error("Jira Query is required.");
        preferences.write("jiraQuery", jiraQuery);

        log("JIRA URL:", jiraUrl);
        log("OmniFocus Tag:", omniFocusTag);
        log("JIRA Query:", jiraQuery);

        // Incremental sync: Determine if we need a full sync or incremental sync
        const lastSyncTime = preferences.readDate("lastSyncTime");
        const lastJiraQuery = preferences.readString("lastJiraQuery");
        const forceFullSync = app.optionKeyDown; // Hold Option key to force full sync
        
        // Determine if this should be a full sync
        const isFullSync = forceFullSync || !lastSyncTime || lastJiraQuery !== jiraQuery;
        
        let effectiveJiraQuery = jiraQuery;
        let syncType = "full";
        
        if (!isFullSync) {
          // Incremental sync: only fetch tickets updated since last sync
          // Note: Jira API expects ISO 8601 format with +0000 (UTC) timezone
          const lastSyncISO = lastSyncTime.toISOString().split(".")[0] + "+0000";
          effectiveJiraQuery = `(${jiraQuery}) AND updated >= "${lastSyncISO}"`;
          syncType = "incremental";
          log("Incremental sync: fetching tickets updated since", lastSyncTime.toISOString());
        } else {
          if (forceFullSync) {
            log("Full sync: forced by user (Option key held)");
          } else if (!lastSyncTime) {
            log("Full sync: first sync (no previous sync time)");
          } else if (lastJiraQuery !== jiraQuery) {
            log("Full sync: JQL query changed");
          }
        }
        
        log("Effective JIRA Query:", effectiveJiraQuery);

        // Find the tag
        const tag = getOrCreateTagFromPath(omniFocusTag);

        if (!tag) {
          console.error(new Error("could not create tag"));
          return;
        }
        const tasks = tag.tasks;

        // cache object instead of array so search will be faster later
        const omnifocusTasks = Object.create(null);
        const matchedKeys = new Set();
        const jiraKeyRegex = new RegExp(`^[A-Z][A-Z0-9]+-\\d+`);
        tasks.forEach((task) => {
          const name = task && typeof task.name === "string" ? task.name : "";
          const match = name.match(jiraKeyRegex);
          const taskId = match && match[0] ? match[0] : null;
          if (!taskId) return;
          omnifocusTasks[taskId] = task;
        });

        // Validate API Key
        const validateUrl = jiraUrl + "/rest/api/3/myself";
        const validateJson = await fetchJiraJson({ url: validateUrl, authHeader });
        log(
          "Validated Jira credentials for:",
          validateJson.displayName || validateJson.emailAddress || "current user"
        );

        const jiraFields = ["key", "summary", "description"];

        const fetchJiraIssues = async (startAt = 0) => {
          const urlParams = `/rest/api/3/search/jql?fields=${jiraFields}&maxResults=${maxResultsPerPage}&startAt=${startAt}&jql=${encodeURIComponent(
            effectiveJiraQuery
          )}`;
          const url = jiraUrl + urlParams;
          log("URL:", url);

          const jsonResponse = await fetchJiraJson({ url, authHeader });

          log("start", jsonResponse.startAt);
          log("maxResults", jsonResponse.maxResults);
          log("total", jsonResponse.total);

          // The new API uses 'values' instead of 'issues'
          const issues = jsonResponse.values || jsonResponse.issues || [];
          for (const issue of issues) {
            // Search if we need to add a new Task
            checkedTickets++;
            matchedKeys.add(issue.key);
            const existingTask = omnifocusTasks[issue.key];
            if (existingTask) {
              // Track if task was completed before reopening
              const wasCompleted = existingTask.completed;
              // Make sure the task opens again
              existingTask.markIncomplete();
              if (wasCompleted) {
                syncStats.reopened++;
              }
              continue;
            }

            // There was no Matching Task, so we create the Task
            const summary =
              issue &&
              issue.fields &&
              typeof issue.fields.summary === "string" &&
              issue.fields.summary.trim().length
                ? issue.fields.summary.trim()
                : "(No summary)";
            const taskName = `${issue.key} ${summary}`;
            const newTask = new Task(taskName, inbox.beginning);
            const taskUrl = `${jiraUrl}/browse/${issue.key}`;
            syncStats.created++;

            newTask.addTag(tag);
            const descriptionText = jiraDescriptionToText(
              issue && issue.fields ? issue.fields.description : null
            );
            newTask.note = `${taskUrl}\n${descriptionText}`;
          }

          // Check if there are more results to fetch
          if (
            jsonResponse.startAt + jsonResponse.maxResults <
            jsonResponse.total
          ) {
            await fetchJiraIssues(
              jsonResponse.startAt + jsonResponse.maxResults
            );
          }
        };

        let checkedTickets = 0;

        await fetchJiraIssues();

        // Close Tasks
        for (const [task_id, task] of Object.entries(omnifocusTasks)) {
          if (!matchedKeys.has(task_id)) {
            let canDelete = true;

            if (task.hasChildren) {
              for (const subtask of task.children) {
                if (!subtask.completed) {
                  canDelete = false;
                  break;
                }
              }
            }

            if (canDelete) {
              task.markComplete();
              syncStats.completed++;
            }
          }
        }

        // Calculate sync duration
        const syncDuration = ((Date.now() - syncStartTime) / 1000).toFixed(1);

        // Update preferences after successful sync
        preferences.write("lastSyncTime", new Date());
        preferences.write("lastJiraQuery", jiraQuery);

        // Log to console
        console.log(
          `NOTICE: ${syncType === "incremental" ? "Incremental" : "Full"} sync completed for ${jiraUrl}. Checked ${checkedTickets} Tickets, Created ${syncStats.created} new tasks, Reopened ${syncStats.reopened} tasks, Completed ${syncStats.completed} tasks (${syncDuration}s)`
        );

        // Show summary alert only if changes were made
        const totalChanges =
          syncStats.created + syncStats.reopened + syncStats.completed;
        if (totalChanges > 0) {
          const summaryLines = [];
          summaryLines.push(
            `ðŸ”„ Sync Type: ${syncType === "incremental" ? "Incremental âš¡" : "Full ðŸ”"}`
          );
          if (syncStats.created > 0) {
            summaryLines.push(
              `âœ¨ Created: ${syncStats.created} task${
                syncStats.created !== 1 ? "s" : ""
              }`
            );
          }
          if (syncStats.reopened > 0) {
            summaryLines.push(
              `ðŸ”„ Reopened: ${syncStats.reopened} task${
                syncStats.reopened !== 1 ? "s" : ""
              }`
            );
          }
          if (syncStats.completed > 0) {
            summaryLines.push(
              `âœ“ Completed: ${syncStats.completed} task${
                syncStats.completed !== 1 ? "s" : ""
              }`
            );
          }
          summaryLines.push(`\nTotal time: ${syncDuration}s`);

          const summary = summaryLines.join("\n");
          await new Alert("Jira Sync", summary).show();
        }
      } catch (err) {
        if (!err.message.includes("cancelled")) {
          new Alert(err.name, err.message).show();
        }
      }
    }
  });

  action.validate = function (selection, sender) {
    //
    // This action is always valid.
    //
    return true;
  };

  return action;
})();
