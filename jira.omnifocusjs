/*{
  "type": "action",
  "targets": ["omnifocus"],
  "author": "Mark E. Schill",
  "identifier": "net.cmschill.omnifocus.sync.jira",
  "version": "1.4.1",
  "description": "Sync elements from Jira with Omnifocus",
  "label": "ðŸ”¹ Jira: Sync",
  "shortLabel": "Jira: sync"
}*/
(() => {
  const maxResultsPerPage = 25;

  var shouldLogToConsole = true;

  /**
   * Consolidated logging helper
   * @param {string} message - The message to log
   * @param {...any} args - Additional arguments to log
   */
  const log = (message, ...args) => {
    if (shouldLogToConsole) {
      console.log(message, ...args);
    }
  };

  /**
   * Extract Jira ticket key from task name
   * @param {string} taskName - The task name to extract key from
   * @returns {string|null} The ticket key (e.g., "PROJ-123") or null if not found
   */
  const extractTicketKey = (taskName) => {
    const jiraKeyRegex = /^[A-Z][A-Z0-9]+-\d+/;
    const match = taskName.match(jiraKeyRegex);
    return match ? match[0] : null;
  };

  /**
   * Find or create a tag by path
   * @param {string} tagPath - The tag path (can be "tag" or "Parent : Child")
   * @returns {Tag} The found or created tag
   * @throws {Error} If tag cannot be created
   */
  const findOrCreateTag = (tagPath) => {
    let tag = null;

    // If user gave an absolute path, parse it and process it
    const parsedTagPath = tagPath.split(" : ");
    if (parsedTagPath.length > 1) {
      let currentTag = null;
      for (let i = 0; i < parsedTagPath.length; i++) {
        let newTag = currentTag
          ? currentTag.childNamed(parsedTagPath[i])
          : tags.byName(parsedTagPath[i]);

        if (!newTag) break;
        currentTag = newTag;
      }

      // Check if the tag was successfully found and apply it
      if (
        currentTag &&
        currentTag.name === parsedTagPath[parsedTagPath.length - 1]
      ) {
        tag = currentTag;
      }
    }

    if (!tag) {
      // If tag is not found yet, try to find or create it
      tag =
        tags.byName(tagPath) ||
        flattenedTags.byName(tagPath) ||
        new Tag(tagPath);
    }

    if (!tag) {
      throw new Error("Could not find or create tag: " + tagPath);
    }

    return tag;
  };

  /**
   * Validate Jira API connection
   * @param {string} jiraUrl - The Jira base URL
   * @param {string} userID - The user ID for authentication
   * @param {string} apiKey - The API key for authentication
   * @returns {Promise<Object>} The validation response JSON
   * @throws {Error} If validation fails
   */
  const validateJiraConnection = async (jiraUrl, userID, apiKey) => {
    const validateUrl = jiraUrl + "/rest/api/3/myself";
    const validateRequest = URL.FetchRequest.fromString(validateUrl);
    validateRequest.method = "GET";
    const validateAuth = Data.fromString(userID + ":" + apiKey).toBase64();
    validateRequest.headers = { Authorization: "Basic " + validateAuth };
    const validateResponse = await validateRequest.fetch();
    if (validateResponse.statusCode !== 200) {
      throw new Error("JIRA API Key is invalid or expired.");
    }
    const validateJson = JSON.parse(validateResponse.bodyString);
    if (validateJson.apiKey && validateJson.apiKey.expiry) {
      log("API Key Expiration:", validateJson.apiKey.expiry);
    } else {
      log("API Key is valid. Expiration date not provided by Jira.");
    }
    return validateJson;
  };
  var serviceTitle = "JIRA Sync";
  var credentials = new Credentials();
  var preferences = new Preferences();
  var action = new PlugIn.Action(async function (selection, sender) {
    log("Starting JIRA Sync...");

    var credentialsObj = credentials.read(serviceTitle);

    if (app.controlKeyDown) {
      // Prompt the user to confirm the removal of stored credentials
      const alertMessage = "Remove the stored credentials?";
      const alert = new Alert("Confirmation Required", alertMessage);
      alert.addOption("Reset");
      alert.addOption("Cancel");

      // Show the alert and get the user's response
      const buttonIndex = await alert.show();

      // If the user chose "Reset", remove the stored credentials
      if (buttonIndex === 0) {
        credentials.remove(serviceTitle);
      }
    } else if (!credentialsObj) {
      inputForm = new Form();

      const userIDField = new Form.Field.String("userID", "User ID", null);
      if (Device.iPad || Device.iOS) {
        userIDField.autocapitalizationType = TextAutocapitalizationType.None;
      }

      const APIKeyField = new Form.Field.String("apiKey", "API Key", null);
      if (Device.iPad || Device.iOS) {
        APIKeyField.autocapitalizationType = TextAutocapitalizationType.None;
      }

      inputForm.addField(userIDField);
      inputForm.addField(APIKeyField);

      inputForm.validate = (formObject) => {
        const userID = formObject.values["userID"];
        const APIKey = formObject.values["apiKey"];
        return userID && APIKey ? true : false;
      };

      const formPrompt = "Enter your JIRA credentials:";
      const formObject = await inputForm.show(formPrompt, "Continue");

      const userID = formObject.values["userID"];
      const apiKey = formObject.values["apiKey"];

      credentials.write(serviceTitle, userID, apiKey);
    } else {
      try {
        // Start timing the sync
        const syncStartTime = Date.now();

        // Initialize sync statistics
        const syncStats = {
          created: 0,
          reopened: 0,
          completed: 0
        };

        var userID = credentialsObj.user;
        var apiKey = credentialsObj.password;

        log("User ID:", userID);
        log("API Key:", apiKey);

        jiraUrl =
          preferences.readString("jiraUrl") || "https://jira.atlassian.com";
        jiraUrlInputField = new Form.Field.String("jiraUrl", "URL", jiraUrl);

        omniFocusTag = preferences.readString("omniFocusTag") || "jira";
        omniFocusTagInputField = new Form.Field.String(
          "omniFocusTag",
          "OmniFocus Tag",
          omniFocusTag
        );

        jiraQuery =
          preferences.readString("jiraQuery") ||
          "assignee=currentuser() and resolution is empty";
        jiraQueryInputField = new Form.Field.String(
          "jiraQuery",
          "JIRA Search Query",
          jiraQuery
        );

        inputForm = new Form();
        inputForm.addField(jiraUrlInputField);
        inputForm.addField(omniFocusTagInputField);
        inputForm.addField(jiraQueryInputField);
        formPrompt = action.label;
        formObject = await inputForm.show(formPrompt, "Continue");

        var jiraUrl = formObject.values["jiraUrl"];
        preferences.write("jiraUrl", jiraUrl);
        var omniFocusTag = formObject.values["omniFocusTag"];
        preferences.write("omniFocusTag", omniFocusTag);
        var jiraQuery = formObject.values["jiraQuery"];
        preferences.write("jiraQuery", jiraQuery);

        log("JIRA URL:", jiraUrl);
        log("OmniFocus Tag:", omniFocusTag);
        log("JIRA Query:", jiraQuery);

        // Find or create the tag
        const tag = findOrCreateTag(omniFocusTag);
        const tasks = tag.tasks;

        // cache object instead of array so search will be faster later
        let omnifocusTasks = {};
        tasks.forEach((task) => {
          const taskId = extractTicketKey(task.name);
          if (!taskId) return;
          omnifocusTasks[taskId] = task;
          // Reset Jira Match Flag
          omnifocusTasks[taskId].jiraToOmnifocusMatched = false;
        });

        // Validate API Key
        await validateJiraConnection(jiraUrl, userID, apiKey);

        const jiraFields = ["key", "summary", "description"];

        const fetchJiraIssues = async (startAt = 0) => {
          const urlParams = `/rest/api/3/search/jql?fields=${jiraFields}&maxResults=${maxResultsPerPage}&startAt=${startAt}&jql=${encodeURIComponent(
            jiraQuery
          )}`;
          const url = jiraUrl + urlParams;
          log("URL: ", url);

          const request = URL.FetchRequest.fromString(url);
          request.method = "GET";
          const data = Data.fromString(userID + ":" + apiKey);
          const authHeader = "Basic " + data.toBase64();

          request.headers = { Authorization: authHeader };
          const response = await request.fetch();

          if (response.mimeType == "application/json") {
            const jsonResponse = JSON.parse(response.bodyString);

            // Check for API errors
            if (jsonResponse.errorMessages || jsonResponse.errors) {
              console.error(
                "API Error Response:",
                JSON.stringify(jsonResponse, null, 2)
              );
              throw new Error(
                jsonResponse.errorMessages
                  ? jsonResponse.errorMessages.join(", ")
                  : "API returned an error"
              );
            }

            log("start", jsonResponse.startAt);
            log("maxResults", jsonResponse.maxResults);
            log("total", jsonResponse.total);

            // The new API uses 'values' instead of 'issues'
            const issues = jsonResponse.values || jsonResponse.issues || [];
            for (const issue of issues) {
              // Search if we need to add a new Task
              checkedTickets++;
              const existingTask = omnifocusTasks[issue.key];
              if (existingTask) {
                // Track if task was completed before reopening
                const wasCompleted = existingTask.completed;
                // Make sure the task opens again
                existingTask.markIncomplete();
                if (wasCompleted) {
                  syncStats.reopened++;
                }
                existingTask.jiraToOmnifocusMatched = true;
                continue;
              }

              // There was no Matching Task, so we create the Task
              const taskName = `${issue.key} ${issue.fields.summary}`;
              const newTask = new Task(taskName, inbox.beginning);
              const taskUrl = `${jiraUrl}/browse/${issue.key}`;
              syncStats.created++;

              newTask.addTag(tag);
              newTask.note = `${taskUrl}\n${
                issue.fields.description || "No description"
              }`;
            }

            // Check if there are more results to fetch
            if (
              jsonResponse.startAt + jsonResponse.maxResults <
              jsonResponse.total
            ) {
              await fetchJiraIssues(
                jsonResponse.startAt + jsonResponse.maxResults
              );
            }
          }
        };

        let checkedTickets = 0;

        await fetchJiraIssues();

        // Close Tasks
        for (const [task_id, task] of Object.entries(omnifocusTasks)) {
          if (!task.jiraToOmnifocusMatched) {
            let canDelete = true;

            if (task.hasChildren) {
              for (const subtask of task.children) {
                if (!subtask.completed) {
                  canDelete = false;
                  break;
                }
              }
            }

            if (canDelete) {
              task.markComplete();
              syncStats.completed++;
            }
          }
        }

        // Calculate sync duration
        const syncDuration = ((Date.now() - syncStartTime) / 1000).toFixed(1);

        // Log to console
        log(
          `NOTICE: Synced ${jiraUrl}. Checked ${checkedTickets} Tickets, Created ${syncStats.created} new tasks, Reopened ${syncStats.reopened} tasks, Completed ${syncStats.completed} tasks (${syncDuration}s)`
        );

        // Show summary alert only if changes were made
        const totalChanges = syncStats.created + syncStats.reopened + syncStats.completed;
        if (totalChanges > 0) {
          const summaryLines = [];
          if (syncStats.created > 0) {
            summaryLines.push(`âœ¨ Created: ${syncStats.created} task${syncStats.created !== 1 ? "s" : ""}`);
          }
          if (syncStats.reopened > 0) {
            summaryLines.push(`ðŸ”„ Reopened: ${syncStats.reopened} task${syncStats.reopened !== 1 ? "s" : ""}`);
          }
          if (syncStats.completed > 0) {
            summaryLines.push(`âœ“ Completed: ${syncStats.completed} task${syncStats.completed !== 1 ? "s" : ""}`);
          }
          summaryLines.push(`\nTotal time: ${syncDuration}s`);

          const summary = summaryLines.join("\n");
          await new Alert("Jira Sync", summary).show();
        }
      } catch (err) {
        if (!err.message.includes("cancelled")) {
          new Alert(err.name, err.message).show();
        }
      }
    }
  });

  action.validate = function (selection, sender) {
    //
    // This action is always valid.
    //
    return true;
  };

  return action;
})();
